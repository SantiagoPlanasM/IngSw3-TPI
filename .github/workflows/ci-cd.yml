name: üéì TPI Final Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  # ====================================================
  # ETAPA 1: BUILD & UNIT TESTS (Reporte Visual)
  # ====================================================
  unit-tests-build:
    name: üß™ Unit Tests & Build
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Bajar C√≥digo
        uses: actions/checkout@v4

      - name: üêπ Instalar Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          cache-dependency-path: backend/go.sum

      # PASO 1: Correr tests guardando el resultado en JSON
      # El '|| true' es importante: evita que el pipeline se corte aqu√≠ mismo si falla un test.
      # Queremos que siga al siguiente paso para dibujar la tabla roja antes de morir.
      - name: üß™ Ejecutar Unit Tests (JSON)
        run: |
          cd backend
          go test ./... -json > test_report.json || true

      # PASO 2: Generar la Tabla Hermosa Fila por Fila
      - name: üìä Generar Reporte Detallado
        run: |
          cd backend
          # T√≠tulo del reporte
          echo "### üî¨ Reporte Detallado de Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Cabecera de la tabla
          echo "| Clase/Paquete | Test Case | Resultado | Duraci√≥n |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :---: | :---: |" >> $GITHUB_STEP_SUMMARY
          
          # Magia con JQ: Convierte el JSON de Go en filas de tabla Markdown
          # Filtra solo los eventos 'pass' o 'fail' que tengan nombre de test
          jq -r 'select(.Action == "pass" or .Action == "fail") | select(.Test != null) | "| \(.Package) | \(.Test) | " + (if .Action == "pass" then "‚úÖ PASS" else "‚ùå FAIL" end) + " | \(.Elapsed)s |"' test_report.json >> $GITHUB_STEP_SUMMARY

      # PASO 3: Ahora s√≠, verificar si hubo fallos para detener el pipeline
      - name: üõë Verificar Fallos
        run: |
          cd backend
          # Buscamos si hay alg√∫n "fail" en el archivo JSON
          if grep -q '"Action":"fail"' test_report.json; then
            echo "‚ùå Se encontraron tests fallidos. Abortando Build."
            exit 1
          else
            echo "‚úÖ Todos los tests pasaron."
          fi

      # PASO 4: Build del Frontend (Solo si lo anterior pas√≥)
      - name: üì¶ Verificar Build Frontend
        run: |
          cd frontend
          npm ci
          npm run build

  # ====================================================
  # ETAPA 2: INTEGRATION & DEPLOY QA
  # ====================================================
  integration-deploy-qa:
    name: üöÄ Integration & QA Deploy
    needs: unit-tests-build # <--- ESTO ASEGURA QUE SI FALLA EL ANTERIOR, ESTE NO CORRE
    runs-on: ubuntu-latest
    environment: 
      name: QA
      url: https://web-pedidos-dev.onrender.com
    
    # Base de datos temporal para pruebas de integraci√≥n
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: orders_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: üì• Bajar C√≥digo
        uses: actions/checkout@v4

      - name: üêπ Instalar Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          cache-dependency-path: backend/go.sum

 # PASO 1: Ejecutar Tests de Integraci√≥n (JSON)
      - name: üî¨ Ejecutar Tests de Integraci√≥n
        env:
          # VITAL: Tu c√≥digo pide esta variable para no saltarse los tests
          INTEGRATION_TEST: "true" 
          DATABASE_URL: postgres://testuser:testpassword@localhost:5432/orders_test?sslmode=disable
        run: |
          cd backend
          go mod download
          # Corremos los tests y guardamos el JSON. "|| true" evita que corte ac√°.
          go test ./tests/integration/... -v -json > integration_report.json || true

      # PASO 2: Generar Tabla Visual
      - name: üìä Generar Reporte Visual Integraci√≥n
        run: |
          cd backend
          echo "### üîå Reporte de Integraci√≥n (Base de Datos Real)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Escenario de Test | Resultado | Duraci√≥n |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :---: | :---: |" >> $GITHUB_STEP_SUMMARY
          
          # JQ filtra los resultados (incluyendo los sub-tests t.Run)
          jq -r 'select(.Action == "pass" or .Action == "fail") | select(.Test != null) | "| \(.Test) | " + (if .Action == "pass" then "‚úÖ PASS" else "‚ùå FAIL" end) + " | \(.Elapsed)s |"' integration_report.json >> $GITHUB_STEP_SUMMARY

      # PASO 3: Verificar Fallos y Abortar
      - name: üõë Verificar Integraci√≥n
        run: |
          cd backend
          if grep -q '"Action":"fail"' integration_report.json; then
            echo "‚ùå Fallaron las pruebas de integraci√≥n. NO SE DESPLIEGA A QA."
            exit 1
          else
            echo "‚úÖ Integraci√≥n exitosa."
          fi

      # REQUISITO: "Pipeline realiza deploy autom√°ticamente a QA"
      - name: üöÄ Deploy a Render (QA)
        run: |
          echo "‚úÖ Tests pasados. Desplegando a QA..."
          curl -X POST ${{ secrets.RENDER_HOOK_BACKEND }}
          curl -X POST ${{ secrets.RENDER_HOOK_FRONTEND }}

  # ====================================================
  # ETAPA 3: PASE A PRODUCCI√ìN (APROBACI√ìN MANUAL)
  # ====================================================
  deploy-production:
    name: üèÜ Deploy a Producci√≥n
    needs: integration-deploy-qa
    runs-on: ubuntu-latest
    # REQUISITO: "Aprobaci√≥n manual para el pase a PROD"
    environment: 
      name: Production # Al estar protegido en GitHub, pedir√° permiso
      url: https://ingsw3-tpi-1.onrender.com
    
    steps:
      - name: üöÄ Deploy a Render (PROD)
        run: |
          echo "üö® Aprobaci√≥n Manual Recibida. Desplegando a PROD..."
          curl -X POST ${{ secrets.RENDER_HOOK_BACKEND }}
          curl -X POST ${{ secrets.RENDER_HOOK_FRONTEND }}